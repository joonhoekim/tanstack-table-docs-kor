"use strict";(self.webpackChunktanstack_table_kor=self.webpackChunktanstack_table_kor||[]).push([[3445],{8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>l});var n=a(6540);const s={},o=n.createContext(s);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(o.Provider,{value:t},e.children)}},8469:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"framework/qwik/guide/table-state","title":"Table State (Qwik) Guide","description":"Table State (Qwik) Guide","source":"@site/docs/framework/qwik/guide/table-state.md","sourceDirName":"framework/qwik/guide","slug":"/framework/qwik/guide/table-state","permalink":"/tanstack-table-docs-kor/framework/qwik/guide/table-state","draft":false,"unlisted":false,"editUrl":"https://github.com/joonhoekim/tanstack-table-docs-kor/tree/main/docs/framework/qwik/guide/table-state.md","tags":[],"version":"current","frontMatter":{"title":"Table State (Qwik) Guide"}}');var s=a(4848),o=a(8453);const i={title:"Table State (Qwik) Guide"},l=void 0,r={},c=[{value:"Table State (Qwik) Guide",id:"table-state-qwik-guide",level:2},{value:"Accessing Table State",id:"accessing-table-state",level:3},{value:"Custom Initial State",id:"custom-initial-state",level:3},{value:"Controlled State",id:"controlled-state",level:3},{value:"Individual Controlled State",id:"individual-controlled-state",level:4},{value:"Fully Controlled State",id:"fully-controlled-state",level:4},{value:"On State Change Callbacks",id:"on-state-change-callbacks",level:3},{value:"1. <strong>State Change Callbacks MUST have their corresponding state value in the <code>state</code> option</strong>.",id:"1-state-change-callbacks-must-have-their-corresponding-state-value-in-the-state-option",level:4},{value:"2. <strong>Updaters can either be raw values or callback functions</strong>.",id:"2-updaters-can-either-be-raw-values-or-callback-functions",level:4},{value:"State Types",id:"state-types",level:3}];function u(e){const t={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"table-state-qwik-guide",children:"Table State (Qwik) Guide"}),"\n",(0,s.jsx)(t.p,{children:"TanStack Table has a simple underlying internal state management system to store and manage the state of the table. It also lets you selectively pull out any state that you need to manage in your own state management. This guide will walk you through the different ways in which you can interact with and manage the state of the table."}),"\n",(0,s.jsx)(t.h3,{id:"accessing-table-state",children:"Accessing Table State"}),"\n",(0,s.jsxs)(t.p,{children:["You do not need to set up anything special in order for the table state to work. If you pass nothing into either ",(0,s.jsx)(t.code,{children:"state"}),", ",(0,s.jsx)(t.code,{children:"initialState"}),", or any of the ",(0,s.jsx)(t.code,{children:"on[State]Change"})," table options, the table will manage its own state internally. You can access any part of this internal state by using the ",(0,s.jsx)(t.code,{children:"table.getState()"})," table instance API."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"const table = useQwikTable({\n  columns,\n  data,\n  //...\n})\n\nconsole.log(table.getState()) //access the entire internal state\nconsole.log(table.getState().rowSelection) //access just the row selection state\n"})}),"\n",(0,s.jsx)(t.h3,{id:"custom-initial-state",children:"Custom Initial State"}),"\n",(0,s.jsxs)(t.p,{children:["If all you need to do for certain states is customize their initial default values, you still do not need to manage any of the state yourself. You can simply set values in the ",(0,s.jsx)(t.code,{children:"initialState"})," option of the table instance."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"const table = useQwikTable({\n  columns,\n  data,\n  initialState: {\n    columnOrder: ['age', 'firstName', 'lastName'], //customize the initial column order\n    columnVisibility: {\n      id: false //hide the id column by default\n    },\n    expanded: true, //expand all rows by default\n    sorting: [\n      {\n        id: 'age',\n        desc: true //sort by age in descending order by default\n      }\n    ]\n  },\n  //...\n})\n"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note"}),": Only specify each particular state in either ",(0,s.jsx)(t.code,{children:"initialState"})," or ",(0,s.jsx)(t.code,{children:"state"}),", but not both. If you pass in a particular state value to both ",(0,s.jsx)(t.code,{children:"initialState"})," and ",(0,s.jsx)(t.code,{children:"state"}),", the initialized state in ",(0,s.jsx)(t.code,{children:"state"})," will take overwrite any corresponding value in ",(0,s.jsx)(t.code,{children:"initialState"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"controlled-state",children:"Controlled State"}),"\n",(0,s.jsxs)(t.p,{children:["If you need easy access to the table state in other areas of your application, TanStack Table makes it easy to control and manage any or all of the table state in your own state management system. You can do this by passing in your own state and state management functions to the ",(0,s.jsx)(t.code,{children:"state"})," and ",(0,s.jsx)(t.code,{children:"on[State]Change"})," table options."]}),"\n",(0,s.jsx)(t.h4,{id:"individual-controlled-state",children:"Individual Controlled State"}),"\n",(0,s.jsx)(t.p,{children:"You can control just the state that you need easy access to. You do NOT have to control all of the table state if you do not need to. It is recommended to only control the state that you need on a case-by-case basis."}),"\n",(0,s.jsxs)(t.p,{children:["In order to control a particular state, you need to both pass in the corresponding ",(0,s.jsx)(t.code,{children:"state"})," value and the ",(0,s.jsx)(t.code,{children:"on[State]Change"})," function to the table instance."]}),"\n",(0,s.jsx)(t.p,{children:'Let\'s take filtering, sorting, and pagination as an example in a "manual" server-side data fetching scenario. You can store the filtering, sorting, and pagination state in your own state management, but leave out any other state like column order, column visibility, etc. if your API does not care about those values.'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"const columnFilters = Qwik.useSignal([]) //no default filters\nconst sorting = Qwik.useSignal([{\n  id: 'age',\n  desc: true, //sort by age in descending order by default\n}]) \nconst pagination = Qwik.useSignal({ pageIndex: 0, pageSize: 15 })\n\n//Use our controlled state values to fetch data\nconst tableQuery = useQuery({\n  queryKey: ['users', columnFilters.value, sorting.value, pagination.value],\n  queryFn: () => fetchUsers(columnFilters.value, sorting.value, pagination.value),\n  //...\n})\n\nconst table = useQwikTable({\n  columns: columns.value,\n  data: tableQuery.data,\n  //...\n  state: {\n    columnFilters: columnFilters.value, //pass controlled state back to the table (overrides internal state)\n    sorting: sorting.value,\n    pagination: pagination.value,\n  },\n  onColumnFiltersChange: updater => {\n    columnFilters.value = updater instanceof Function ? updater(columnFilters.value) : updater //hoist columnFilters state into our own state management\n  },\n  onSortingChange: updater => {\n    sorting.value = updater instanceof Function ? updater(sorting.value) : updater\n  },\n  onPaginationChange: updater => {\n    pagination.value = updater instanceof Function ? updater(pagination.value) : updater\n  },\n})\n//...\n"})}),"\n",(0,s.jsx)(t.h4,{id:"fully-controlled-state",children:"Fully Controlled State"}),"\n",(0,s.jsxs)(t.p,{children:["Alternatively, you can control the entire table state with the ",(0,s.jsx)(t.code,{children:"onStateChange"})," table option. It will hoist out the entire table state into your own state management system. Be careful with this approach, as you might find that raising some frequently changing state values up a component tree, like ",(0,s.jsx)(t.code,{children:"columnSizingInfo"})," state`, might cause bad performance issues."]}),"\n",(0,s.jsxs)(t.p,{children:["A couple of more tricks may be needed to make this work. If you use the ",(0,s.jsx)(t.code,{children:"onStateChange"})," table option, the initial values of the ",(0,s.jsx)(t.code,{children:"state"})," must be populated with all of the relevant state values for all of the features that you want to use. You can either manually type out all of the initial state values, or use the ",(0,s.jsx)(t.code,{children:"table.setOptions"})," API in a special way as shown below."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"//create a table instance with default state values\nconst table = useQwikTable({\n  columns,\n  data,\n  //... Note: `state` values are NOT passed in yet\n})\n\n\nconst sate = Qwik.useSignal({\n  ...table.initialState, //populate the initial state with all of the default state values from the table instance\n  pagination: {\n    pageIndex: 0,\n    pageSize: 15 //optionally customize the initial pagination state.\n  }\n})\n\n//Use the table.setOptions API to merge our fully controlled state onto the table instance\ntable.setOptions(prev => ({\n  ...prev, //preserve any other options that we have set up above\n  state: state.value, //our fully controlled state overrides the internal state\n  onStateChange: updater => {\n    state.value = updater instanceof Function ? updater(state.value) : updater //any state changes will be pushed up to our own state management\n  },\n}))\n"})}),"\n",(0,s.jsx)(t.h3,{id:"on-state-change-callbacks",children:"On State Change Callbacks"}),"\n",(0,s.jsxs)(t.p,{children:["So far, we have seen the ",(0,s.jsx)(t.code,{children:"on[State]Change"})," and ",(0,s.jsx)(t.code,{children:"onStateChange"}),' table options work to "hoist" the table state changes into our own state management. However, there are a few things about these using these options that you should be aware of.']}),"\n",(0,s.jsxs)(t.h4,{id:"1-state-change-callbacks-must-have-their-corresponding-state-value-in-the-state-option",children:["1. ",(0,s.jsxs)(t.strong,{children:["State Change Callbacks MUST have their corresponding state value in the ",(0,s.jsx)(t.code,{children:"state"})," option"]}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Specifying an ",(0,s.jsx)(t.code,{children:"on[State]Change"})," callback tells the table instance that this will be a controlled state. If you do not specify the corresponding ",(0,s.jsx)(t.code,{children:"state"}),' value, that state will be "frozen" with its initial value.']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"const sorting = Qwik.useSignal([])\n//...\nconst table = useQwikTable({\n  columns,\n  data,\n  //...\n  state: {\n    sorting: sorting.value, //required because we are using `onSortingChange`\n  },\n  onSortingChange: updater => {\n    sorting.value = updater instanceof Function ? updater(sorting) : updater //makes the `state.sorting` controlled\n  }, \n})\n"})}),"\n",(0,s.jsxs)(t.h4,{id:"2-updaters-can-either-be-raw-values-or-callback-functions",children:["2. ",(0,s.jsx)(t.strong,{children:"Updaters can either be raw values or callback functions"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"on[State]Change"})," and ",(0,s.jsx)(t.code,{children:"onStateChange"})," callbacks work exactly like the ",(0,s.jsx)(t.code,{children:"setState"})," functions in React. The updater values can either be a new state value or a callback function that takes the previous state value and returns the new state value."]}),"\n",(0,s.jsxs)(t.p,{children:["What implications does this have? It means that if you want to add in some extra logic in any of the ",(0,s.jsx)(t.code,{children:"on[State]Change"})," callbacks, you can do so, but you need to check whether or not the new incoming updater value is a function or value."]}),"\n",(0,s.jsxs)(t.p,{children:["This is why you will see the ",(0,s.jsx)(t.code,{children:"updater instanceof Function ? updater(state.value) : updater"})," pattern in the examples above. This pattern checks if the updater is a function, and if it is, it calls the function with the previous state value to get the new state value."]}),"\n",(0,s.jsx)(t.h3,{id:"state-types",children:"State Types"}),"\n",(0,s.jsx)(t.p,{children:"All complex states in TanStack Table have their own TypeScript types that you can import and use. This can be handy for ensuring that you are using the correct data structures and properties for the state values that you are controlling."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import { useQwikTable, type SortingState } from '@tanstack/qwik-table'\n//...\nconst sorting = Qwik.useSignal<SortingState[]>([\n  {\n    id: 'age', //you should get autocomplete for the `id` and `desc` properties\n    desc: true,\n  }\n])\n"})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);